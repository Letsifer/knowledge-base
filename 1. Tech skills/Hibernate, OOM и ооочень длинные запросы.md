# Сергей Синдеев — Hibernate, OOM и ооочень длинные запросы

Кратко в докладе описывает процесс нахождения причин OOM при выполнении запросов, и как их пофиксить.

Исходная причина: контейнер раз в час падал с OOM, хотя у него было выделено 22 Gb.

1. Посмотрели график использования JVM-хипа. Т.к. раз в час падало, то посмотрели задания планировщиков - все было корректно
<details>
  <summary>см.скрин</summary>
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/a2f51c65-c0ee-4c28-9658-7ecc000b90de)
</details>

2. Подключились профилировщиком, проанализировали график использование памяти. Пики (резкие подьемы использования памяти) - места кандидатов на проблему, хотя их причина неясна. Пилообразный паттерн графика - характерная
чертя работы GC (сборки мусора), но полностью почистить не может. В логах посмотрели по пикам, что в это время было - но запросов явных сложных не было, запросы ходят и в другое время без проблем.
<details>
  <summary>см.скрин</summary>
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/b7711148-a003-449f-8f54-8a4cd792f603)
</details>

3. Взяли дамп памяти
   * Его можно получить ключами VM. Основной ключ - HeapDumpOnOutOfMemoryError, также в контексте докера важен флаг HeapDumpPath (позже опишет, что он нужен для сохранения дампа вне контейнера, т.к.
при остановке приложения контейнер уничтожается вместе со снятым дампом). Также можно снять дамп с помощью JMX.
   * Также можно снять дамп, если приложение использует Spring Boot, а именно бибилиотека spring-boot-startr-actuator, но нужны параметры + нужна настройка доступа Spring Security.
Из минусов - нужно по сути передавать, что замедляет процесс снятия. 
<details>
  <summary>см.скрины обоих пунктов</summary>
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/f2d4780c-4807-4f83-9d18-3b55cf7063b8)
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/a9156035-5381-4d10-8d83-bfae47b0dd9e)
</details>

4. Далее дамп нужно анализировать, например, с помощью MAT (Eclipse Memory analyzer tool). Дамп показал 2 потенциальные проблемы
   * Первая проблема была с сбором статистики (был включен параметр spring.jpa.properties.hibernate.generate_statistics=true). Она позволяет библиотекам логирования показывать данные планов запросов... Разработчики
  не рекомендуют всегда использовать на product-среде. Они ее отключили, далее сравнивают до-после дампы
   * Дампы сравнивать напрямую некорректно, т.к. они сняты в разное время. Момены
       * Remainder - поведение объектов, которые хорошо управляются, т.е. не утечки. Их размеры примерно одинаковы.
       * Часть B слева и часть A справа - утечка, она экпансивно растет (SessionFactoryImpl - раздача сессий + кеш)
<details>
  <summary>см.скрин</summary>
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/b616437f-fd4a-4f73-841c-bdabb4712d5f)
  ![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/a9ea58ce-37a3-41ea-b1e2-a6f2d39a55d7)
</details>

5. Находим размера объекта со связями. QueryPlanCache имеет огромный размер. Напрямую его уменьшать бессмысленно, т.к. кеш позволяет ускорять работу приложений, сохраняя планы запросов. Запросы чаще всего имеет размер
+-1Кб, но один запрос имеет порядка 130Мб.
<details>
  <summary>см.скрин</summary>
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/2655f4de-ba31-4b38-9130-d693bb470d90)
</details>

6. С помощью SQL-подобного синтаксиса в MAT можно найти объект, который хранит запрос. MAT может обрезать параметры, так что это может сбить с толку. Итого выяснилось, что текст запроса весил 19Мб, что очень много
<details>
  <summary>см.скрин</summary>
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/b1a38ee6-4457-415e-b2d8-f8e1168c596d)
</details>

7. Исправляем запрос
   * Логировать запрос, найти, как он выглядит
   * В данном случае проблема была в огромном IN, так что запрос можно разбить на куски с количеством не более BATCH_SIZE в IN. В первом запуске запроса будет построено его синтаксическое дерево, Hibernate его запоминает.
     Однако впоследствии, построения дерева не будет, что ускоряет работу
   * hibernate.query.in_clause_parameter_padding=ON/OFF, при ON в IN параметры будет в количестве кратно 2. В других случаях последний параметр скопируется до следующей степень (пример, при IN с 10 параметрами будет добито
     до 16). Цель - в кеше будет храниться меньше вариантов запросов, а для БД копия заначений смысла не имеет.

8. Итог. Потребление памяти снизились (+-7Гб, а раньше не хватало 22Гб), OOM и рестарты прекратились, пила памяти стала меньше.

   
Ссылка на видео - https://www.youtube.com/watch?v=KUmzw-gAhCY
