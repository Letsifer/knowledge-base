# Алексей Пименов. Управление зависимостями

От зависимостей надо избавляться, а не управлять ими. Однако отказ от одних зависимостей порождает необходимость других зависимостей. Т.е. избавление от зависимостей - некий
недостижимый идеал, а в процессе отказа зависимостями надо управлять.
Управление зависимостями позволяет ответить на вопрос - когда? (это будет сделано). Иногда - а нужно ли это делать? 
Для ответа на вопрос производственная система (т.е. набор команд) должна быть ограничена, т.е. в ней должно быть ограниченное количество единиц работ (в штуках).
Также система должна быть визуализирована - т.е. видеть на каком этапе разработки сейчас работа (т.е. Канбан-доска)

Зависимость может быть 
* исследуемая. По жизни любая зависимость должна быть такой, т.е. можем ли мы ее выявить. Т.е. зависимость может быть
  * выявляемая - т.е. сколько времени и ресурсов можно потратить на выявление зависимости, т.е.
  * невыявляемая
* неисследуемая

Паттерны поведения с работой
* Ускоренная - для сверхсрочной работы
* Фиксированная - для работы с дедлайном
* Стандартный - обычная работа, все задачи делаются строго по очереди
* Нематериальный - работа для выполнения в фоновом режиме, по остаточному принципу

Система разервирования от Sami Honkonen. 
Проблема при управлении зависимостями - надо передать в другую команду задачу для ее выполнения, где эта задача может "сгнить" в беклоге.
Идея №1 - договориться с этой командой (которая тоже ограниченная система), что у них будет в фиксированную дату взять задачу в работу.
Идея №2 - классы резервации
* ожидающий - "если вы не успеете на этот поезд, то поедете на следующий", вероятность (70-85%)
* резервированный - "вам зарезерваировано место в самолете, и вы даже знаете номер кресла", вероятность "сесть" очень велика (>90-95%)
* гарантированный - "всегда держится место в самолете, если надо вылететь, то просто приезжаете в аэропорт". Гарантия 100%, но очень дорого по ресурсам

Определение классов резервации с точки зрения параметров команды. Для этого надо понимать количество произ. элементов (фича...) в единицу времени, выпускаемых командой.
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/c552cd5d-080a-4448-9440-c3841bc98e84)
Указан график количества выпускаемых единиц в разные единицы времени (например за разные месяца).
* Гарантированый - все, что ниже минимума (примерно на рисунке < 10)
* Резервированный - нижняя половина расстояния от среднего арифметического до минимума (примерно на рисунке 10-15)
* Ожидающий - верхняя половина расстояния от среднего арифметического до минимума (примерно на рисунке 15-20)

![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/8f5c15a5-0a3a-451b-8252-1d14b82577a6)
Вызывающая система:
* Нам подконтрольна, т.е. можем ее ограничить (покрыть лимитом)
* Раз она ограничена, то мы можем статистически предсказать время от колонки "План" до колонки "Этап 2 - в работе" (т.е. до зависимости)
* Раз она ограничена, то мы можем статистически предсказать время от колонки "Этап 2 - готово" до колонки "Готово" (т.е. после зависимости)
* Время, проведенное задачей в вызываемой системе нам неизвестно, а значит мы не можем предсказать полное время производства

Вызываемая система:
* Нам неподконтрольна, мы не можем диктовать ей правила
* Однако если менеджер системы смог ограничить ее (покрыть лимитом), то время производства этой системы становится нам предсказемо

Временная шкала для определения времени работы над задачей, т.е. когда мы сможем сказать срок готовности задачи
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/8418766f-0499-43ff-acb1-9cf72f4b3281)

Есть несколько классов управления зависимостямии
1. Зависимость не ищется или не может быть выявлена, т.е. мы зависимостью не управлеем, вызываемая система не ограничена, т.е. время нахождения задачи в беклоге и в работе
вызываемой системы рандомно. Подходит для несрочных задач, стоимость задержки задачи крайне мала, "сделаем когда-нибудь". Система резервирования не используется, в обоих
системах используется паттерн "Нематериальный".
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/a3b595dd-3850-44e1-be95-a8547ceeac06)
2. "Доверительная доступность", мы не заботимся о доступности вызываемой системы, но она ограничена, т.е. нам известно время выполнения задачи в вызываемой системе. Система
резервирования не используется, в обоих системах используется паттерн "Стандартный".
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/026161c6-f25c-449b-b389-51a23d101af1)
Однако при понимании пропускной способности вызываемой системы (т.е. как уменьшается беклог), то можно вычислить время, когда задача попадет в работу. Если система предсказуема,
то вычислить итоговый срок готовности можно раньше.

До этого - это невыявляемые зависимости, выявлыемые далее.

3. "Митигация хвоста". Зависимость может быть обнаружена, мы будем заботиться о доступности вызываемой системы. В вызывающей системе используется паттерн "Стандартный", в
вызываемой - "Фиксированная дата", класс резервации - "Ожидающий"
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/41d93ddf-0ffe-442c-94c8-893ba3a63220)
4. "Фиксированная дата поставки". В обоих системах используется паттерн - "Фиксированная дата", класс резервации - "Резервированный". Если у задачи есть дедайн, то нам придется
заботиться о доступности вызываемой системы
![изображение](https://github.com/Letsifer/knowledge-base/assets/14146724/aa7674e0-577f-4908-931b-02301b500f7c)
5. "Точно вовремя". В обоих системах используется паттерн - "Фиксированная дата", класс резервации - "Гарантированный". У нас нет права на ошибку, нам нужно иметь
гарантированную доступность обеих систем. Отличие от класса 4 - в классе резерации, критичен срок, даже на +-1 день. Картинка аналогично 4 класса.
6. "Ускоренный".  Система резервирования не используется, в обоих системах используется паттерн "Ускоренный". Нет смысла заморачиваться на выявление зависимости, обе системы
должны работыть в режиме "Бросай все и делай только это"

В 1 и 6 мы не управляем зависимостью.
Для построения 3-5 классов нужно очень хорошо выстроить в организации системы - это мало где используется, т.к. мало где сроки настолько критичны.

Вопросы после доклада:
1. Резервы сроков - уже учтены в статистике выпускаемых задач.
2. Критичность по срокам от классов? 1 класс - всем пофиг, 2 класс - всем пофиг, но желательно сделать, 3 класс - точная дата срока после взятия в работе, 4 класс - точная дата +-1 день, 5 класс - точный день, иначе жесткие санкции
3. Уровень KMM - ML2 (модель орг.зрелости)
4. "А если знаем, что просрем" - то нет смысла искать и что-то выявлять - все тупо делаем.
5. Более сложные графы зависимостей, можно городить Excel-ины с зависимостями, может быть нужна Swift Kanban.
6. 

Ссылка на видео - https://www.youtube.com/watch?v=X8pAlQ8cy6Q&t=1379s.

При анализе помогла статья про методологию Канбан - https://practicum.yandex.ru/blog/metodologiya-kanban/
